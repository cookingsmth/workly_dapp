// pages/api/tasks/[taskId]/delete.ts - –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ —Å –≤–æ–∑–≤—Ä–∞—Ç–æ–º –¥–µ–Ω–µ–≥
import { NextApiRequest, NextApiResponse } from 'next'
import jwt from 'jsonwebtoken'
import fs from 'fs'
import path from 'path'

// –ü—É—Ç–∏ –∫ —Ñ–∞–π–ª–∞–º –¥–∞–Ω–Ω—ã—Ö
const getTasksFilePath = () => path.join(process.cwd(), 'data', 'tasks.json')
const getUsersFilePath = () => path.join(process.cwd(), 'data', 'users.json')
const getEscrowAccountsFilePath = () => path.join(process.cwd(), 'data', 'escrow_accounts.json')
const getPendingEscrowsFilePath = () => path.join(process.cwd(), 'data', 'pending_escrows.json')
const getWalletTransactionsFilePath = () => path.join(process.cwd(), 'data', 'wallet_transactions.json')
const getWalletsFilePath = () => path.join(process.cwd(), 'data', 'wallets.json')

// –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É data –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
const ensureDataDir = () => {
    const dataDir = path.join(process.cwd(), 'data')
    if (!fs.existsSync(dataDir)) {
        fs.mkdirSync(dataDir, { recursive: true })
    }
}

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏
const loadTasks = () => {
    ensureDataDir()
    const filePath = getTasksFilePath()
    if (!fs.existsSync(filePath)) return []
    try {
        const data = fs.readFileSync(filePath, 'utf8')
        return JSON.parse(data)
    } catch (error) {
        console.error('Error loading tasks:', error)
        return []
    }
}

const saveTasks = (tasks: any[]) => {
    ensureDataDir()
    const filePath = getTasksFilePath()
    try {
        fs.writeFileSync(filePath, JSON.stringify(tasks, null, 2))
    } catch (error) {
        console.error('Error saving tasks:', error)
        throw new Error('Failed to save task data')
    }
}

const loadEscrowAccounts = () => {
    ensureDataDir()
    const filePath = getEscrowAccountsFilePath()
    if (!fs.existsSync(filePath)) return []
    try {
        const data = fs.readFileSync(filePath, 'utf8')
        return JSON.parse(data)
    } catch (error) {
        console.error('Error loading escrow accounts:', error)
        return []
    }
}

const saveEscrowAccounts = (escrows: any[]) => {
    ensureDataDir()
    const filePath = getEscrowAccountsFilePath()
    try {
        fs.writeFileSync(filePath, JSON.stringify(escrows, null, 2))
    } catch (error) {
        console.error('Error saving escrow accounts:', error)
        throw new Error('Failed to save escrow data')
    }
}

const loadPendingEscrows = () => {
    ensureDataDir()
    const filePath = getPendingEscrowsFilePath()
    if (!fs.existsSync(filePath)) return []
    try {
        const data = fs.readFileSync(filePath, 'utf8')
        return JSON.parse(data)
    } catch (error) {
        console.error('Error loading pending escrows:', error)
        return []
    }
}

const savePendingEscrows = (escrows: any[]) => {
    ensureDataDir()
    const filePath = getPendingEscrowsFilePath()
    try {
        fs.writeFileSync(filePath, JSON.stringify(escrows, null, 2))
    } catch (error) {
        console.error('Error saving pending escrows:', error)
        throw new Error('Failed to save pending escrow data')
    }
}

const loadWallets = () => {
    ensureDataDir()
    const filePath = getWalletsFilePath()
    if (!fs.existsSync(filePath)) return []
    try {
        const data = fs.readFileSync(filePath, 'utf8')
        return JSON.parse(data)
    } catch (error) {
        console.error('Error loading wallets:', error)
        return []
    }
}

const saveWallets = (wallets: any[]) => {
    ensureDataDir()
    const filePath = getWalletsFilePath()
    try {
        fs.writeFileSync(filePath, JSON.stringify(wallets, null, 2))
    } catch (error) {
        console.error('Error saving wallets:', error)
        throw new Error('Failed to save wallet data')
    }
}

const loadWalletTransactions = () => {
    ensureDataDir()
    const filePath = getWalletTransactionsFilePath()
    if (!fs.existsSync(filePath)) return []
    try {
        const data = fs.readFileSync(filePath, 'utf8')
        return JSON.parse(data)
    } catch (error) {
        console.error('Error loading wallet transactions:', error)
        return []
    }
}

const saveWalletTransactions = (transactions: any[]) => {
    ensureDataDir()
    const filePath = getWalletTransactionsFilePath()
    try {
        fs.writeFileSync(filePath, JSON.stringify(transactions, null, 2))
    } catch (error) {
        console.error('Error saving wallet transactions:', error)
        throw new Error('Failed to save transaction data')
    }
}

const loadUsers = () => {
    const filePath = getUsersFilePath()
    if (!fs.existsSync(filePath)) return []
    try {
        const data = fs.readFileSync(filePath, 'utf8')
        return JSON.parse(data)
    } catch (error) {
        console.error('Error loading users:', error)
        return []
    }
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
const getUserFromToken = (authHeader: string | undefined) => {
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return null
    }

    const token = authHeader.split(' ')[1]

    try {
        const decoded = jwt.verify(
            token,
            process.env.JWT_SECRET || 'workly-local-secret-key-2025'
        ) as { userId: string }

        const users = loadUsers()
        const user = users.find((u: any) => u.id === decoded.userId)

        if (!user) return null

        return {
            id: user.id,
            username: user.username,
            email: user.email
        }
    } catch (error) {
        return null
    }
}

// üéØ –§–£–ù–ö–¶–ò–Ø –í–û–ó–í–†–ê–¢–ê –î–ï–ù–ï–ì –° ESCROW
const refundMoneyFromEscrow = async (taskId: string, clientId: string) => {
    try {
        console.log(`üí∞ Starting refund process for task ${taskId}`)
        
        // –ò—â–µ–º escrow –≤ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–∞—Ö
        let escrowAccounts = loadEscrowAccounts()
        let pendingEscrows = loadPendingEscrows()
        let wallets = loadWallets()
        let transactions = loadWalletTransactions()
        
        // –ù–∞–π—Ç–∏ escrow –¥–ª—è –¥–∞–Ω–Ω–æ–π –∑–∞–¥–∞—á–∏
        const escrowIndex = escrowAccounts.findIndex(escrow => 
            escrow.taskId === taskId && escrow.status === 'funded'
        )
        
        const pendingIndex = pendingEscrows.findIndex(escrow => 
            escrow.taskId === taskId || (escrow.taskData && escrow.taskData.createdBy === clientId)
        )
        
        let refundAmount = 0
        let refundToken = ''
        let escrowToRemove = null
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ escrow (—Å–æ —Å—Ç–∞—Ç—É—Å–æ–º 'funded')
        if (escrowIndex !== -1) {
            const escrow = escrowAccounts[escrowIndex]
            refundAmount = escrow.amount // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–ª–Ω—É—é —Å—É–º–º—É –∑–∞–∫–∞–∑—á–∏–∫—É
            refundToken = escrow.token
            escrowToRemove = escrow
            
            console.log(`üí∏ Found funded escrow: ${refundAmount} ${refundToken}`)
            
            // –£–¥–∞–ª—è–µ–º escrow –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö
            escrowAccounts.splice(escrowIndex, 1)
            saveEscrowAccounts(escrowAccounts)
        }
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–∂–∏–¥–∞—é—â–µ–≥–æ escrow (pending_payment)
        else if (pendingIndex !== -1) {
            const pendingEscrow = pendingEscrows[pendingIndex]
            refundAmount = pendingEscrow.amount || pendingEscrow.taskData?.reward?.amount || 0
            refundToken = pendingEscrow.token || pendingEscrow.taskData?.reward?.token || 'SOL'
            escrowToRemove = pendingEscrow
            
            console.log(`‚è≥ Found pending escrow: ${refundAmount} ${refundToken}`)
            
            // –£–¥–∞–ª—è–µ–º –∏–∑ pending (–¥–µ–Ω—å–≥–∏ –µ—â–µ –Ω–µ –±—ã–ª–∏ —Å–ø–∏—Å–∞–Ω—ã)
            pendingEscrows.splice(pendingIndex, 1)
            savePendingEscrows(pendingEscrows)
        }
        
        // –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω escrow –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞
        if (escrowToRemove && refundAmount > 0) {
            // –ù–∞—Ö–æ–¥–∏–º –∫–æ—à–µ–ª–µ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            const walletIndex = wallets.findIndex(wallet => wallet.userId === clientId)
            
            if (walletIndex !== -1) {
                const wallet = wallets[walletIndex]
                
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–µ–Ω—å–≥–∏ –Ω–∞ –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                switch (refundToken.toUpperCase()) {
                    case 'SOL':
                        wallet.solBalance += refundAmount
                        break
                    case 'USDT':
                        wallet.usdtBalance += refundAmount
                        break
                    case 'USDC':
                        wallet.usdcBalance += refundAmount
                        break
                    case 'WORKLY':
                        wallet.worklyBalance += refundAmount
                        break
                    default:
                        console.warn(`Unknown token type: ${refundToken}`)
                        return false
                }
                
                wallet.lastUpdated = new Date().toISOString()
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –∫–æ—à–µ–ª–µ–∫
                saveWallets(wallets)
                
                // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤–æ–∑–≤—Ä–∞—Ç–∞
                const refundTransaction = {
                    id: Date.now().toString(),
                    type: 'task_refund_manual',
                    userId: clientId,
                    taskId: taskId,
                    escrowAddress: escrowToRemove.escrowAddress,
                    amount: refundAmount,
                    token: refundToken,
                    timestamp: new Date().toISOString(),
                    description: `Manual refund for deleted task ${taskId}`
                }
                
                transactions.push(refundTransaction)
                saveWalletTransactions(transactions)
                
                console.log(`‚úÖ Successfully refunded ${refundAmount} ${refundToken} to user ${clientId}`)
                return {
                    success: true,
                    refundAmount,
                    refundToken,
                    escrowAddress: escrowToRemove.escrowAddress
                }
            } else {
                console.error(`‚ùå Wallet not found for user ${clientId}`)
                return { success: false, error: 'Wallet not found' }
            }
        } else {
            console.log(`‚ÑπÔ∏è No escrow found for task ${taskId} - no refund needed`)
            return { success: true, refundAmount: 0, refundToken: 'NONE' }
        }
        
    } catch (error) {
        console.error('‚ùå Error during refund process:', error)
        return { success: false, error: error.message }
    }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    const { method, query } = req
    const { taskId } = query

    if (method !== 'DELETE') {
        return res.status(405).json({
            error: 'Method not allowed',
            message: `Method ${method} is not supported on this endpoint`
        })
    }

    try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
        const user = getUserFromToken(req.headers.authorization)

        if (!user) {
            return res.status(401).json({
                error: 'Unauthorized',
                message: 'Authentication required to delete tasks'
            })
        }

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –∑–∞–¥–∞—á–∏
        const tasks = loadTasks()
        const taskIndex = tasks.findIndex(task => task.id === taskId)

        if (taskIndex === -1) {
            return res.status(404).json({
                error: 'Task not found',
                message: `Task with ID ${taskId} does not exist`
            })
        }

        const task = tasks[taskIndex]

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞: —Ç–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç —É–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É
        if (task.createdBy !== user.id) {
            return res.status(403).json({
                error: 'Forbidden',
                message: 'You can only delete tasks you created'
            })
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏: –º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å —Ç–æ–ª—å–∫–æ –æ—Ç–∫—Ä—ã—Ç—ã–µ –∑–∞–¥–∞—á–∏
        if (task.status !== 'open') {
            return res.status(400).json({
                error: 'Invalid task status',
                message: `Cannot delete task with status: ${task.status}. Only open tasks can be deleted.`
            })
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∑–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—é
        if (task.assignedTo) {
            return res.status(400).json({
                error: 'Task already assigned',
                message: 'Cannot delete task that is already assigned to a worker'
            })
        }

        console.log(`üóëÔ∏è Deleting task ${taskId} by user ${user.id}`)

        // üéØ –í–û–ó–í–†–ê–©–ê–ï–ú –î–ï–ù–¨–ì–ò –° ESCROW
        const refundResult = await refundMoneyFromEscrow(taskId, user.id)

        if (!refundResult.success) {
            return res.status(500).json({
                error: 'Refund failed',
                message: `Failed to process refund: ${refundResult.error}`,
                taskDeleted: false
            })
        }

        // –£–¥–∞–ª—è–µ–º –∑–∞–¥–∞—á—É
        tasks.splice(taskIndex, 1)
        saveTasks(tasks)

        console.log(`‚úÖ Task ${taskId} successfully deleted with refund`)

        // –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
        const response = {
            success: true,
            message: 'Task deleted successfully',
            taskId: taskId,
            refund: {
                processed: refundResult.refundAmount > 0,
                amount: refundResult.refundAmount,
                token: refundResult.refundToken,
                escrowAddress: refundResult.escrowAddress
            }
        }

        res.status(200).json(response)

    } catch (error) {
        console.error('Delete task error:', error)
        res.status(500).json({
            error: 'Internal server error',
            message: 'Failed to delete task'
        })
    }
}